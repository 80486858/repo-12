/*
 *  Copyright 2021-2022 Disney Streaming
 *
 *  Licensed under the Tomorrow Open Source Technology License, Version 1.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     https://disneystreaming.github.io/TOST-1.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package smithy4s.codegen

/**
  * This construct aims at adding metadata information to the classpath to let Smithy4s
  * know about code that may have been generated in upstream modules.
  *
  * A "smithy4sGenerated" metadata holds a list of all namespaces that will have already
  * been generated by smithy4s.
  */
private[smithy4s] object SmithyResources {

  def produce(
      resourceOutputFolder: os.Path,
      localSmithyFiles: List[os.Path],
      namespaces: List[String]
  ): List[os.Path] = {

    val smithyFolder = resourceOutputFolder / "META-INF" / "smithy"
    val namespaceTrackingSmithyFiles = namespaces.map { ns =>
      val filePath = smithyFolder / s"smithy4s.$ns.smithy"
      val content = s"""|$$version: "2.0"
                        |
                        |metadata smithy4sGenerated = ["$ns"]
                        |""".stripMargin
      (filePath, content)
    }
    val localCopyBindings = localSmithyFiles.map { path =>
      (path, smithyFolder / path.last)
    }
    val allSmithyFiles =
      namespaceTrackingSmithyFiles.map(_._1) ++ localCopyBindings.map(_._2)

    val metadataFile = smithyFolder / "manifest"

    val metadataFileContent =
      allSmithyFiles.map(_.last).mkString(System.lineSeparator())

    os.write.over(
      metadataFile,
      metadataFileContent,
      createFolders = true
    )

    namespaceTrackingSmithyFiles.map { case (path, content) =>
      os.write.over(path, content, createFolders = true)
    }

    localCopyBindings.foreach { case (from, to) =>
      os.copy(
        from,
        to,
        replaceExisting = true,
        createFolders = true
      )
    }

    val allProducedFiles = metadataFile :: allSmithyFiles
    allProducedFiles
  }

}

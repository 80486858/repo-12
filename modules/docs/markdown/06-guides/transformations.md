---
sidebar_label: Transformations and generalisation
title: Transformations and generalisation
---

It is often the case that users may want to manipulate the generated interfaces in a generic way, be that to transform the context in which the interface operates, or to apply some generic behaviour when running methods.

The generated code provided by Smithy4s contains the required methods and instances to be able to write transformations very generically. In particular, all generated service interfaces come with an associated `FunctorK5`, which means they can be "mapped" by using a function that
operates over higher-kinded types with 5 type parameters. Yes, this is scary, but indirections are present to make it easier for the end user.

```scala mdoc:passthrough
docs.InlineSmithyFile("greet.smithy")
```


```scala mdoc
import smithy4s._
import foo._

type Result[A] = Either[String, A]

// Assuming `GreetService` was generated by smithy4s.
val greetServiceEither: GreetService[Result] = new GreetService[Result]{
  def greet(name: String) : Result[GreetOutput] =
    if (name.isEmpty) Left("What's your name ?")
    else Right(GreetOutput(s"Hello $name!"))
}

// Creating a polymorphic function turning Either to Option :
val toOption: PolyFunction[Result, Option] = new PolyFunction[Result, Option]{
  def apply[A](result: Result[A]): Option[A] = result.toOption
}

// transforming our service :
val greetServiceOption: GreetService[Option] = greetServiceEither.transform(toOption)

println(greetServiceOption.greet("John"))
```

#### Lifting errors into the type system

It is possible to lift the errors known by a service in Smithy into the type system, to get an accurate reflection
in the Scala code of some of the errors that may happen during the execution of an operation.

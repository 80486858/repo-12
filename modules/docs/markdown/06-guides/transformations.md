---
sidebar_label: Transformations and generalisation
title: Transformations and generalisation
---

It is often the case that users may want to manipulate the generated interfaces in a generic way, be that to transform the context in which the interface operates, or to apply some generic behaviour when running methods.

The generated code provided by Smithy4s contains the required methods and instances to be able to write transformations very generically. In particular, all generated service interfaces come with an associated `FunctorK5`, which means they can be "mapped" by using a function that
operates over higher-kinded types with 5 type parameters. Yes, this is scary, but indirections are present to make it easier for the end user.

```scala mdoc:passthrough
docs.InlineSmithyFile("greet.smithy")
```


```scala mdoc
import smithy4s._
import foo._

type Result[A] = Either[String, A]

// Assuming `GreetService` was generated by smithy4s.
val greetServiceEither: GreetService[Result] = new GreetService[Result]{
  def greet(name: String) : Result[GreetOutput] =
    if (name.isEmpty) Left("What's your name ?")
    else Right(GreetOutput(s"Hello $name!"))
}

// Creating a polymorphic function turning Either to Option :
val toOption: PolyFunction[Result, Option] = new PolyFunction[Result, Option]{
  def apply[A](result: Result[A]): Option[A] = result.toOption
}

// transforming our service :
val greetServiceOption: GreetService[Option] = greetServiceEither.transform(toOption)

println(greetServiceOption.greet("John"))
```

## Error-related transformations

Using transformations, it is possible to surface errors into the context a service operates, or, in the contrary, to absorb errors to make them disappear from the context. The generated interfaces contain the accurate information associated to each method, and the companion
objects contain the necessary constructs to transform typed-errors into throwables and to recover type-errors from throwables.

```scala mdoc:passthrough
docs.InlineSmithyFile("kvstore.smithy")
```

### Surfacing errors

```scala mdoc

import smithy4s.example._
import smithy4s.Transformation
import scala.util.{Failure, Success, Try}

object kvStoreTry extends KVStore[Try] {
  def delete(key: String): Try[Unit] = Success(())
  def put(key: String, value: String): Try[Unit] = Success(())
  def get(key: String): Failure[Value] = Failure(KeyNotFoundError(s"Key $key wasn't found"))
}

// SurfaceError allows to go from mono-functor to bi-functor.
val toEither: Transformation.SurfaceError[Try, Either] =
  new Transformation.SurfaceError[Try, Either] {
    def apply[E, A](
        value: Try[A],
        catcher: Throwable => Option[E]
    ): Either[E, A] = value match {
      case Success(value) => Right(value)
      case Failure(error) =>
        catcher(error) match {
          case None    => throw error // don't do this at work!
          case Some(e) => Left(e)
        }
    }
  }

val kvStoreEither: KVStore.WithError[Either] = kvStoreTry.transform(toEither)
val result: Either[KVStore.GetError, Value] = kvStoreEither.get("foo")
```

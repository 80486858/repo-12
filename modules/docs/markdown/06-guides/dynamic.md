---
sidebar_label: Dynamic module
title: Dynamic module
---

<!-- todo: remove this if we move this page to 05-design/ -->
It is highly recommended to learn about [the library's design](../05-design/01-design.md) before going into this section.

Smithy4s is first and foremost a code generation tool for the Smithy language in Scala. Although it does provide interpreters for the Smithy services, which can be used to derive e.g. HTTP clients and servers, the codegen way can only get you so far - there are some situations when it's **not sufficient for the job**.

Code generation works well if your Smithy model changes **no more often** than your service's implementation - as long as you run your build whenever you make a code change, codegen will also be triggered,
and the Scala compiler will ensure you're in sync with the Smithy model in its present state. But what if your Smithy model changes are **more frequent** than the service? Or what if you simply don't have access to all the Smithy models your code might have to work with?

These cases, and possibly others, are why Smithy4s has the `dynamic` module.

## The static world, the dynamic world

As you know by now, Smithy4s's codegen is static - it requires the model to be available at build-time, so that code can be generated and made available to you at compile-time.

In short, what happens at **build-time** are the following steps:

1. **Read** the Smithy files available to your build
2. **Build** a [semantic Smithy model](https://smithy.io/2.0/spec/model.html), which is roughly a graph of shapes that refer to each other
3. **Generate** files for each relevant shape in the model (e.g. a service, a structure, an enum...), including metadata ([services](../05-design/03-services.md) and [schemas](../05-design/02-schemas.md)).

Then, there's the **runtime** part. Let's say you're building a HTTP client - in that case, what you see as a Smithy4s user is:


```scala
SimpleRestJson(WeatherService)
  .client(??? : org.http4s.client.Client[IO])
  .use
```

or more generically:

```
interpretToRestClient(WeatherService)
```

The steps that the HTTP client interpreter performs to build a high-level client are:

1. **Capture** a [Smithy4s service](../05-design/03-services.md) representing the service you wrote in Smithy. This was generated by Smithy4s's codegen.
2. **Analyze** the service's endpoints, their input/output schemas, the Hints on these schemas...
3. **Transform** the service description into a high-level proxy to the underlying client implementation.

Turns out that interpreters like this **aren't _actually_ aware** of the fact that there's code generation involved. As long as you can provide a data structure describing your service, its endpoints and their schemas (which is indeed the `Service` type),
you can use any interpreter that requires one: code generation is just **a means to derive** such a data structure automatically from your Smithy model.

This all is why **you don't _need_ code generation** to benefit from the interpreters - you just need a way to instantiate a Smithy4s Service (or Schema, if that's what your interpreter operates on).

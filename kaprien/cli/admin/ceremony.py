#
# Ceremony
#
import json
import os
from dataclasses import asdict, dataclass
from enum import Enum
from typing import Any, Dict, Optional

from rich import box, markdown, prompt, table  # type: ignore
from rich.console import Console  # type: ignore
from securesystemslib.exceptions import (  # type: ignore
    CryptoError,
    Error,
    FormatError,
    StorageError,
)
from securesystemslib.interface import (  # type: ignore
    import_ed25519_privatekey_from_file,
)

from kaprien.cli import click
from kaprien.cli.admin import admin
from kaprien.helpers.api_client import URL, Methods, is_logged, request_server
from kaprien.helpers.tuf import RolesKeysInput, initialize_metadata

CEREMONY_INTRO = """
# Repository Metadata and Settings for Kaprien

Create a new Repository Metadata and Settings

Kaprien is an implementation for The Update Framework (TUF) as a Service to be
deployed in Cloud or on premisses, protecting your target files repository.

TUF helps developers maintain the security of software update systems,
providing protection even against attackers that compromise the repository or
signing keys. TUF provides a flexible framework and specification that
developers can adopt into any software update system.

More about TUF access https://theupdateframework.io
"""

CEREMONY_INTRO_ROLES_RESPONSABILITIES = """

## Roles and Responsabilities
Kaprien implements Roles and Responsibilities based on TUF top roles (`root`,
`targets`, `timestamp`, and `snapshot`) and implements the **delegated roles**
`bin` and `bins`.

The inspiration for Kaprien is the
[Python Enhancement Proposal 458](https://peps.python.org/pep-0458/).



                       .-------------,
            .--------- |   root *    |-----------.
            |          `-------------'           |
            |                 |                  |
            V                 V                  V
    .-------------,    .-------------,    .-------------,
    |  timestamp  |    |  snapshot   |    |   targets * |
    `-------------'    `-------------'    `-------------'
                                                 |
                                                 V
                                          .-------------,
                             .............|     bin *   |
                             .            `-------------'
                             .                   .
                             .                   .
                             V                   V
                      .-------------,     .-------------,
                      |  bins 0-X   | ... |  bin X-FF   |
                      `-------------'     `-------------'
    * offline keys

The explantion will follow an example of the Organization Example Inc.

**root**

The root role is the locus of trust for the entire repository. The root role
signs the root.json metadata file. This file indicates which keys are
authorized for each of the top-level roles, including for the root role itself.
The roles “root”, “snapshot”, “timestamp” and “targets” must be specified and
each has a list of public keys.

Minimum recomended: 2 Keys and Threshould equal 1.

Example: The organization Example Inc, will use 2 keys and threshold of 1.
Keys Owners: CTO (Jimi Hendrix) and VP of Security (Janis Joplin).

**targets**

The targets role is responsible for indicating which target files are available
from the repository. More precisely, it shares the responsibility of providing
information about the content of updates. The targets role signs targets.json
metadata, and can delegate trust for repository files to bin Role.

Recomended: 2 Keys and Threshold equal 2. Keys discarded after the ceremony.

Example: The organization Example Inc, will use 2 keys and threshold of 2 keys.
The Keys will be generated by the Security Team and discarded after the
Ceremony.

**bin**

The bin role is a target delegated role (delegated by targets Role) and is
responsible to delegate to the bins Role. This role controls the delegation
to the Hash Bins Roles (bins).

Recomended: 2 Keys and Threshold equal 2.

Example: The organization Example Inc, will use 2 keys and threshold of 2 keys.
Key Owners: Head of Development (Kurt Kobain) and Release Manager
(Chris Cornel).

**bins**

The bins role is a target delegated role (delegated by bin role) and is
responsible sign the target files in the file repositories. This key is an
online key.

Recomended: 1 Key and Threshold equal 1

Example: The organization Example Inc, will use 1 key and thresold of 1 key.
Key Owner: DevOpsSec Team

**snapshot**

The snapshot role is responsible for ensuring that clients see a consistent
repository state. It provides repository state information by indicating the
latest versions of the top-level targets and delegated targets metadata files
on the repository in snapshot.json. root and timestamp are not listed in
snapshot.json, because timestamp signs for its freshness, after snapshot.json
has been created, and root, which has all top-level keys, is required ahead of
time to trust any of the top-level roles.

Recomended: 1 Key and Threshold equal 1

Example: The organization Example Inc, will use 1 key and thresold of 1 key.
Key Owner: DevOps Team

**timestamp**

The timestamp role is responsible for providing information about the
timeliness of available updates. Timeliness information is made available by
frequently signing a new timestamp.json file that has a short expiration time.
This file indicates the latest version of snapshot.json.

Recomended: 1 Key and Threshold equal 1

Example: The organization Example Inc, will use 1 key and thresold of 1 key.
Key Owner: DevOps Team
"""

STEP_1 = """
# STEP 1: Configure the Roles

The TUF roles supports multiple keys and the threshold (quorun trust)
defines the minimal number of the keys required to take actions using
specific Role.

Reference: [TUF](https://theupdateframework.github.io/specification/latest/#goals-for-pki)

"""  # noqa

STEP_2 = """
# STEP 2: Load roles keys

The keys must to have a password and the file must to be accessible.

Depending of the Organization, each key has an owner. During the the key
loading process is important that the owner of the key insert the password.

The password or the key content is not shown in the screen.
"""

STEP_3 = """
# STEP 3: Validate configuration

The information below is the configuration done in the preview steps.
Check the number of keys, the threshold/quorun and type of key.

"""

PATHS_DELEGATION_MESSAGE = """
The role *targets* delegates `paths` to `bin`
role. See
[TUF Specification about Path Pattern](
    https://theupdateframework.github.io/specification/latest/#pathpattern
) for the paths pattern and the example.
"""

PATHS_EXAMPLE = """

Example:
--------

The Organization Example (https://example.com) has all files downloaded
`/downloads` path, meaning https://example.com/downloads/.

Additionally it has two sub-folders, `productA` and `productB` where the
clients can find all files (i.e.: `productA-v1.0.tar`, `productB-1.0.tar`), for
`productB`it has even a sub-folder, `updates` where clients can find update
files (i.e.: `servicepack-1.tar`, `servicepack-2.tar`)

In that case mapping all targets files paths as:
- https://example.com/downloads/ is `*`
- https://example.com/downloads/productA/ is `*/*`
- https://example.com/downloads/productB/ is `*/*` (same as above)
- https://example.com/downloads/productB/updates/ is `*/*/*`

Specific paths that role `targets` delegates are:
``*/productA/*, */productB/*, * /productB/updates/*``

Generic paths that role targets delegates are: ``*, */*, */*/*``
"""

console = Console()


class Roles(Enum):
    ROOT = "root"
    TARGETS = "targets"
    SNAPSHOT = "snapshot"
    TIMESTAMP = "timestamp"
    BIN = "bin"
    BINS = "bins"


@dataclass
class RoleSettings:
    expiration: int
    threshold: int
    keys: int
    offline_keys: bool


default_settings = {
    Roles.ROOT.value: RoleSettings(356, 1, 2, True),
    Roles.TARGETS.value: RoleSettings(365, 1, 2, True),
    Roles.SNAPSHOT.value: RoleSettings(1, 1, 1, False),
    Roles.TIMESTAMP.value: RoleSettings(1, 1, 1, False),
    Roles.BIN.value: RoleSettings(365, 1, 1, True),
    Roles.BINS.value: RoleSettings(1, 1, 1, False),
}


@dataclass
class Key:
    key: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


@dataclass
class ServiceSettings:
    targets_base_url: str

    def to_dict(self):
        return asdict(self)


@dataclass
class PayloadSettings:
    roles: Dict[str, RolesKeysInput]
    service: ServiceSettings


OFFLINE_KEYS = {Roles.ROOT.value, Roles.TARGETS.value, Roles.BIN.value}

# generate the basic data structure
SETTINGS = PayloadSettings(
    roles={role.value: RolesKeysInput() for role in Roles},
    service=ServiceSettings(targets_base_url=""),
)


def _key_is_duplicated(key: Dict[str, Any]) -> bool:
    for role in SETTINGS.roles.values():
        if any(k for k in role.keys.values() if key == k.get("key")):
            return True
        if any(k for k in role.keys.values() if key == k.get("path")):
            return False

    return False


def _load_key(filepath: str, password: str) -> Key:
    try:
        key = import_ed25519_privatekey_from_file(filepath, password)
        return Key(key=key)
    except CryptoError as err:
        return Key(
            error=(
                f":cross_mark: [red]Failed[/]: {str(err)} Check the"
                " password."
            )
        )

    except (StorageError, FormatError, Error) as err:
        return Key(error=f":cross_mark: [red]Failed[/]: {str(err)}")


def _configure_role(rolename: str, role: RolesKeysInput) -> None:
    # default reset when start configuration
    role.keys.clear()

    role.threshold = default_settings[rolename].threshold
    role.offline_keys = default_settings[rolename].offline_keys

    role.expiration = prompt.IntPrompt.ask(
        (
            f"\nWhat [green]Metadata expiration[/] for [cyan]{rolename}[/]"
            " role?(Days)"
        ),
        default=default_settings[rolename].expiration,
        show_default=True,
    )

    role.num_of_keys = prompt.IntPrompt.ask(
        (
            f"What is the [green]number of keys[/] for "
            f"[cyan]{rolename}[/] role?"
        ),
        default=default_settings[rolename].keys,
        show_default=True,
    )
    if role.num_of_keys > 1:
        role.threshold = prompt.IntPrompt.ask(
            (
                f"What is the key [green]threshold[/] for "
                f"[cyan]{rolename}[/] role signing?"
            ),
            default=default_settings[rolename].threshold,
            show_default=True,
        )
    else:
        role.threshold = 1
        console.print(
            f"The [green]threshold[/] for [cyan]{rolename}[/] is "
            "[cyan]1[/] (one) based on the number of keys "
            "([cyan]1[/])."
        )

    if rolename == Roles.TARGETS.value:
        console.print(markdown.Markdown(PATHS_DELEGATION_MESSAGE), width=100)
        show_example = prompt.Confirm.ask("Show example", default="y")
        if show_example:
            console.print(markdown.Markdown(PATHS_EXAMPLE), width=100)

        targets_base_url = click.prompt(
            "\nWhat is the Base URL (i.e.: https://www.example.com/downloads/)"
        )
        if targets_base_url.endswith("/") is False:
            targets_base_url = targets_base_url + "/"

        SETTINGS.service.targets_base_url = targets_base_url

        input_paths = prompt.Prompt.ask(
            f"\nWhat [green]paths[/] [cyan]{rolename}[/] delegates?",
            default="*, */*",
            show_default=True,
        )
        delegate_paths = [path.strip() for path in input_paths.split(",")]
        role.paths = delegate_paths

    elif rolename == Roles.BINS.value:
        role.number_hash_prefixes = prompt.IntPrompt.ask(
            f"[green]Number of hashed bins[/] for [cyan]{rolename}[/]?",
            default=8,
            show_default=True,
        )


def _configure_keys(rolename: str, role: RolesKeysInput) -> None:
    key_count = 1
    while len(role.keys) < role.num_of_keys:
        filepath = prompt.Prompt.ask(
            f"\nEnter {key_count}/{role.num_of_keys} the "
            f"[cyan]{rolename}[/]`s Key [green]path[/]"
        )

        password = click.prompt(
            f"Enter {key_count}/{role.num_of_keys} the "
            f"{rolename}`s Key password",
            hide_input=True,
        )
        key: Key = _load_key(filepath, password)

        if key.error:
            console.print(key.error)
            try_again = prompt.Confirm.ask("Try again?", default="y")
            if try_again:
                continue
            else:
                raise click.ClickException("Required key not validated.")

        if key.key is not None and _key_is_duplicated(key.key) is True:
            console.print(":cross_mark: [red]Failed[/]: Key is duplicated.")
            continue

        role.keys[f"{rolename}_{key_count}"] = {
            "filename": filepath.split("/")[-1],
            "password": password,
            "key": key.key,
        }
        console.print(
            ":white_check_mark: Key "
            f"{key_count}/{role.num_of_keys} [green]Verified[/]"
        )
        key_count += 1


def _check_server(settings):
    server = settings.get("SERVER")
    token = settings.get("TOKEN")
    if server and token:
        token_access_check = is_logged(server, token)
        if token_access_check.state is False:
            raise click.ClickException(
                f"{str(token_access_check.data)}"
                "\n\nTry re-login: 'kaprien admin login'"
            )

        expired_admin = token_access_check.data.get("expired")
        if expired_admin is True:
            raise click.ClickException(
                "Token expired. Run 'kaprien admin login'"
            )
        else:
            headers = {"Authorization": f"Bearer {token}"}
            response = request_server(
                server, URL.bootstrap.value, Methods.get, headers=headers
            )
            if response.status_code != 200 and (
                response.json().get("bootstrap") is True or None
            ):
                raise click.ClickException(f"{response.json().get('detail')}")
    else:
        raise click.ClickException("Login first. Run 'kaprien admin login'")

    return headers


def _bootstrap(server, headers, json_payload):
    response = request_server(
        server,
        URL.bootstrap.value,
        Methods.post,
        json_payload,
        headers=headers,
    )
    response_data = response.json()

    if response.status_code != 202:
        raise click.ClickException(
            f"Error {response.status_code} {response_data.get('detail')}"
        )
    elif (
        response_data.get("message") is None
        or response_data.get("message") != "Bootstrap accepted."
    ):
        raise click.ClickException(response.text)
    else:
        console.print("Ceremony and Bootstrap done.")


@admin.command()
@click.option(
    "-b",
    "--bootstrap",
    "bootstrap",
    help=(
        "Bootstrap a Kaprien Server using the Repository Metadata after "
        "Ceremony"
    ),
    required=False,
    is_flag=True,
)
@click.option(
    "-f",
    "--file",
    "file",
    default="payload.json",
    help=(
        "Generate specific JSON Payload compatible with Kaprien Server "
        "bootstrap after Ceremony"
    ),
    show_default=True,
    required=False,
)
@click.option(
    "-u",
    "--upload",
    help=(
        "Upload existent payload 'file'. Requires '-b/--bootstrap'. "
        "Optional '-f/--file' to use non default file."
    ),
    required=False,
    is_flag=True,
)
@click.option(
    "-s",
    "--save",
    help=(
        "Save a copy of the metadata localy. This option saves the metadata "
        "files (json) in the 'metadata' dir."
    ),
    show_default=True,
    is_flag=True,
)
@click.pass_context
def ceremony(context, bootstrap, file, upload, save):
    """
    Start a new Metadata Ceremony.
    """

    if save:
        try:
            os.makedirs("metadata", exist_ok=True)
        except OSError as err:
            raise click.ClickException(str(err))

    if upload is True and bootstrap is False:
        raise click.ClickException("Requires '-b/--bootstrap' option.")

    settings = context.obj["settings"]
    if bootstrap:
        headers = _check_server(settings)
        bs_response = request_server(
            settings.SERVER, URL.bootstrap.value, Methods.get, headers=headers
        )
        bs_data = bs_response.json()
        if bs_response.status_code == 404:
            raise click.ClickException(
                f"Server {settings.SERVER} doesn't allow bootstrap"
            )
        if bs_response.status_code != 200:
            raise click.ClickException(
                f"Error {bs_response.status_code} {bs_data.get('detail')}"
            )

        if bs_data.get("bootstrap") is True or None:
            raise click.ClickException(f"{bs_data.get('message')}")

    if upload is False:
        console.print(markdown.Markdown(CEREMONY_INTRO), width=100)

        ceramony_detailed = prompt.Confirm.ask(
            "\nDo you want more information about Roles and Responsabilities?"
        )
        if ceramony_detailed is True:
            with console.pager():
                console.print(
                    markdown.Markdown(CEREMONY_INTRO_ROLES_RESPONSABILITIES),
                    width=100,
                )

        start_ceremony = prompt.Confirm.ask(
            "\nDo you want start the ceremony?"
        )

        if start_ceremony is False:
            raise click.ClickException("Ceremony aborted.")

        console.print(markdown.Markdown(STEP_1), width=80)
        for rolename, role in SETTINGS.roles.items():
            _configure_role(rolename, role)

        console.print(markdown.Markdown(STEP_2), width=100)
        start_ceremony = prompt.Confirm.ask(
            "\nReady to start loading the keys? Passwords will be "
            "required for keys"
        )
        if start_ceremony is False:
            raise click.ClickException("Ceremony aborted.")

        for rolename, role in SETTINGS.roles.items():
            _configure_keys(rolename, role)

        console.print(markdown.Markdown(STEP_3), width=100)

        for rolename, role in SETTINGS.roles.items():
            while True:
                role_table = table.Table()
                role_table.add_column(
                    "ROLE SUMMARY",
                    style="yellow",
                    justify="center",
                    vertical="middle",
                )
                role_table.add_column(
                    "KEYS", justify="center", vertical="middle"
                )
                keys_table = table.Table(box=box.MINIMAL)
                keys_table.add_column(
                    "path", justify="right", style="cyan", no_wrap=True
                )
                keys_table.add_column("id", justify="center")
                keys_table.add_column("verified", justify="center")
                for key in role.keys.values():
                    keys_table.add_row(
                        key.get("filename"),
                        key.get("key").get("keyid"),
                        ":white_heavy_check_mark:",
                    )

                if role.offline_keys is True:
                    key_type = "[red]offline[/red]"
                else:
                    key_type = "[green]online[/]"

                role_table.add_row(
                    (
                        f"Role: [cyan]{rolename}[/]"
                        f"\nNumber of Keys: {len(role.keys)}"
                        f"\nThreshold: {role.threshold}"
                        f"\nKeys Type: {key_type}"
                        f"\nRole Expiration: {role.expiration} days"
                    ),
                    keys_table,
                )

                if rolename == Roles.TARGETS.value:
                    delegations_row = (
                        f"\n{SETTINGS.service.targets_base_url}".join(
                            ["", *role.paths]
                        )
                    )
                    role_table.add_row(
                        (
                            "\n"
                            "\n[orange1]DELEGATIONS[/]"
                            f"\n[aquamarine3]{rolename} -> bin[/]"
                            f"{delegations_row}"
                        ),
                        "",
                    )

                if rolename == Roles.BINS.value:
                    role_table.add_row(
                        (
                            "\n"
                            "\n[orange1]DELEGATIONS[/]"
                            f"\n[aquamarine3]{rolename} -> bins[/]"
                            f"\nNumber bins: {role.number_hash_prefixes}"
                        ),
                        "",
                    )

                console.print(role_table)
                confirm_config = prompt.Confirm.ask(
                    f"Configuration correct for {rolename}?"
                )
                if not confirm_config:
                    # reconfigure role and keys
                    _configure_role(rolename, role)
                    _configure_keys(rolename, role)
                else:
                    break

        metadata = initialize_metadata(SETTINGS.roles, save=save)

        json_payload: Dict[str, Any] = dict()

        json_payload["settings"] = {"service": SETTINGS.service.to_dict()}
        for role, data in SETTINGS.roles.items():
            if data.offline_keys is True:
                data.keys.clear()

            if "roles" not in json_payload["settings"]:
                json_payload["settings"]["roles"] = {role: data.to_dict()}
            else:
                json_payload["settings"]["roles"][role] = data.to_dict()

        json_payload["metadata"] = {
            key: data.to_dict() for key, data in metadata.items()
        }

        if file:
            with open(file, "w") as f:
                f.write(json.dumps(json_payload, indent=2))

        if bootstrap is True:
            _bootstrap(settings.SERVER, headers, json_payload)

    elif bootstrap is True and upload is True:
        try:
            with open(file) as payload_file:
                json_payload = json.load(payload_file)
        except OSError:
            click.ClickException(f"Invalid file {file}")

        _bootstrap(settings.SERVER, headers, json_payload)
